![](/Users/liuyang/Library/Application%20Support/marktext/images/2023-10-31-16-36-33-image.png)

#### JVM组成

- **程序计数器**：线程私有，每个线程一份，用于记录正在执行的字节码指令地址。

- **堆**：
  
  - 线程共享，用于保存对象实例，数组等，内存不够且无法扩展时，抛出OOM异常
  
  - 组成：**年轻代+老年代**
    
    - 年轻代：Eden区和两个大小相同的Survivor区
    
    - 老年代：保存生命周期比较长的对象，一般是一些老的对象，还有一种就是比较大的对象
  
  - JDK1.7和JDK1.8的区别
    
    - 1.7的堆中有一个方法区（永久代），存储的是类信息、静态变量、常量、编译后的代码等
    
    - 1.8移出了方法区，把数据存储到本地内存的元空间中，防止内存溢出
  
  - 内存不足（OutOfMemoryError）

- 虚拟机栈：线程私有，每个线程运行时创建的内存，存储局部变量和方法调用
  
  - 每个栈由多个栈帧（frame）组成，对应每次方法调用时所占用的内存
  
  - 每个线程只有一个活动的栈帧(执行的方法)
  
  - 垃圾回收主要回收的是堆内存；每个栈帧（方法）执行完成弹出，就会释放内存
  
  - 栈帧一般默认为1024k，在内存固定的情况下，栈帧设计过大会导致线程减少
  
  - 方法内局部变量线程安全
    
    - 局部变量只作用于方法内部，就是线程安全的
    
    - 局部变量是由外部传入或有返回值，就不是线程安全的
  
  - 虚拟机栈内存溢出（StackOverFlowError）
    
    - 栈帧过多，如递归调用没有退出
    
    - 栈帧过大，这个一般不出现

- 元空间（方法区）：线程共享，位置在本地内存，主要存储类的信息，运行常量池
  
  - 虚拟机启动时创建，关闭虚拟机时释放
  
  - 元空间内存不够且无法满足分配请求，会抛出异常OOM（OutOfMemoryError：Metaspace）
  
  - 运行时常量池
    
    - 常量池：可以看作一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息等，属于类
    
    - 当类被加载时，类常量池信息就会被放入**运行时常量池**，并将类常量池中的符号地址变为内存的真实地址

#### 直接内存

- 并不属于JVM中的内存结构，不由JVM管理，是系统内存

- 常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能更高，不受JVM内存回收管理

#### 什么是类加载器？类加载器有哪些？

类加载器就是将**二进制class文件加载到JVM**

- **BootStrapClassLoader**：启动类加载器，由C++实现，加载核心类库jre/lib目录下jar包

- **ExtClassLoader**：扩展类加载器，加载jre/lib/ext目录下jar包

- **AppClassLoader**：应用类加载器，加载开发者自己编写的类，classpath目录下

- **CustomizeClassLoader**：自定义类加载器，实现自定义类加载

#### Java双亲委派机制？为什么采用双亲委派？

<img src="file:///Users/liuyang/Library/Application%20Support/marktext/images/2023-11-01-16-37-18-image.png" title="" alt="" width="304">18-image.png" title="" alt="" width="304">

- 唯一性，通过双亲委派可以避免相同的类（包名+类名都相同）只加载一次

- 安全性，防止恶意篡改API中的类（比如自己编写String类，包名为java.lang，里面的方法运行时会报错）

#### 类装载的执行过程

- 加载：查找、导入class文件

- 连接
  
  - 验证：保证加载类的准确性（安全性校验，文件格式、语法格式、字节码规范、符号引用验证）
  
  - 准备：为类分配内存并设置类变量初始值
    
    - static修饰的变量，赋默认值
    
    - static final修饰的变量，赋初始值
    
    - static final修饰的引用变量，赋null 
  
  - 解析：把类中的符号引用（机器指令中的#号）转换为直接引用（内存地址）

- 初始化：对类的静态变量、静态代码块执行初始化操作
  
  - 将准备阶段未赋初始值的变量，赋初始值

- 使用：JVM开始从入口方法开始执行程序代码

- 卸载：当程序代码执行完成后，JVM开始销毁创建的Class对象

#### 垃圾回收

##### 对象什么时候可以被回收？

如果一个或多个对象没有任何的引用指向它，那么这个对象就是垃圾，如果标记成垃圾，则可能会被垃圾回收器回收。

- 引用计数法：循环引用，导致对象无法回收，造成内存泄露

- 可达性分析法：对象从GCRoot开始进行可达，下面三个可作为GCRoot
  
  - 虚拟机栈中引用的对象
  
  - 方法区中静态属性引用的变量
  
  - 方法区中常量引用的变量

#### JVM垃圾回收算法有哪些？

- 标记清除算法：将垃圾回收分成两个阶段，**标记和清除**
  
  - 根据可达性分析算法，找到垃圾对象进行标记
  
  - 对这些标记为可回收的对象，进行回收
  
  - 优缺点
    
    - 优点：标记、清除速度快
    
    - 缺点：会出现内存碎片化，内存不连贯、造成浪费

- 标记整理算法（老年代）
  
  - 和标记清除一样，但最后将存活对象向内存另一端移动，然后清理边界外的垃圾
  
  - 优缺点
    
    - 优点：相比于标记清除、无碎片
    
    - 缺点：移动对象，效率低

- 标记复制算法（年轻代）
  
  - 根据可达性分析算法，找到垃圾对象进行标记
  
  - 将原有内存分为2部分，每次只使用其中一块，将存活的对象复制到另一块内存中，然后将有垃圾那块内存清空，交换内存角色
  
  - 优缺点
    
    - 优点：垃圾较多的情况下，效率较高；清理后内存无碎片
    
    - 缺点：只使用一半内存，使用率低

#### JVM中的分代回收

##### 堆的区域划分

在JDK1.8中，堆被分成了两部分：**新生代和老年代**：【1:2】

新生代内部又被分成三部分，Eden区存放新生的对象，survivor区存放经过垃圾回收的对象

**Eden区：survivor1(from)：survivor2(to)**【8：1：1】

##### 分代回收策略

1. 新创建的对象，会先分配到Eden区

2. 当Eden区内存不足时，开始minor GC(young GC)，标记eden区和from区的存活对象

3. 将存活对象使用复制算法移动到to区，复制完毕后，eden区和from区内存得到释放

4. 经过一段时间后，eden区再次内存不足，再次开始minorCG，标记eden区和to区的存活对象，将其复制到from区

5. 当对象通过多次（15次）GC，依然存活，将对象晋升到老年代（survivor区内存不足或大对象会提前晋升）

#### MinorGC、MixedGC、FullGC有什么不同

MinorGC（YoungGC）发生在新生代的垃圾回收器，暂停时间短（STW）

MixedGC    新生代+老年代部分区域的垃圾回收，G1收集器特有

FullGC    新生代+老年代全部垃圾回收，暂停时间长（STW）,尽力避免，影响程序性能

#### JVM有哪些垃圾回收器？(重点)

- 串行垃圾回收器（垃圾回收时，只有一个线程工作，其余线程（STW））
  
  - Serial GC：新生代，采用复制算法
  
  - Serial Old GC：老年代，采用标记-整理算法
  
  - 优缺点：
    
    - 优点：单线程执行，简单高效
    
    - 缺点：性能限制，高停顿时间，无法并发进行
  
  - 适用场景：
    
    - 小型应用或测试环境，注重简单和可预测的垃圾回收
    
    - 单线程的小型应用、开发和测试环境

- **并行垃圾回收器**（JDK8默认垃圾回收器，多个垃圾回收线程，其余线程（STW））
  
  - Parallel New GC：新生代，采用复制算法
  
  - Parallel Old GC：老年代，采用标记-整理算法
  
  - 优缺点：
    
    - 优点：并行垃圾回收、低停顿时间、较高的吞吐量、自适应调节
    
    - 缺点：线程同步开销、停顿时间较长、较高的系统资源损耗
  
  - 适用场景：
    
    - 多核处理器环境，强调吞吐量，对停顿时间要求不敏感
    
    - Web服务器、后端应用程序、具有多核处理器的中小型应用

- 并发垃圾回收器（CMS，以获取最短停顿时间的垃圾回收器，特点：垃圾回收时，应用仍然能正常运行）
  
  - CMS（Concurrent Mark Sweep）：老年代，采用标记-清除算法
    
    - 初始标记：其他线程STW
    
    - 并发标记：其他线程运行
    
    - 重新标记：其他线程STW
    
    - 并发清理：其他线程运行
  
  - 优缺点：
    
    - 优点：低停顿时间、垃圾回收线程和应用程序线程并发执行、适用于大内存堆
    
    - 缺点：CPU资源消耗高、需要更多的内存空间、碎片问题（设置参数可以解决）
  
  - 适用场景：
    
    - 多核环境，对停顿时间要求较低，以及与ParNew配合使用，注重减少全局停顿时间
    
    - 大型企业应用、Web应用服务器、需要快速响应的实时系统

- G1垃圾回收器（新生代+老年代，JDK9之后默认使用G1）
  
  - **将Java内存划分为多个区域**，每个区域都可以成为Eden、survivor、old、humongous区，其中humongous专为大对象准备
  
  - **采用复制算法**
  
  - 分成三个阶段：
    
    - 新生代回收（STW）
    
    - 并发标记（重新标记STW）
    
    - 混合收集
  
  - 优缺点：
    
    - 优点：可预测停顿时间、内存整理和碎片处理、并行和并发进行、可控的内存回收
    
    - 缺点：初始标记和重新标记的停顿时间、需要更多的系统资源
  
  - 适用场景：
    
    - 大内存堆环境，对停顿时间要求较低，高吞吐量，注重整体性能，需要更可控的垃圾回收行为
    
    - 大型企业应用、高性能计算、需要可预测停顿时间的实时系统

- ZGC收集器（Region内存布局）
  
  - **标记-整理算法**
  
  - 优缺点：
    
    - 优点：低停顿时间、分代压缩、可扩展性、适应动态环境
    
    - 缺点：垃圾回收性能低、初始标记时间、内存压缩
  
  - 适应场景：
    
    - 大内存堆环境，对停顿时间要求极低，注重低延迟，需要高吞吐量，对内存占用敏感
    
    - 大规模互联网应用、云计算环境、需要处理大内存的实时系统

#### 强软弱虚引用

- 强引用：能被GC Root找到，引用的对象就不会被回收

- 软引用：配合SoftReference使用，当垃圾回收后，内存依然不足时，引用的对象会被回收

- 弱引用：配合WeakReference使用，只要有垃圾回收，引用的对象就会被回收

- 虚引用：配合队列使用，GC时会入队列，但是只有在**这个对象所有这样的引用被清除或者自身变得不可访问**才会回收所指向的对象。
  
  ```java
  // 虚引用必须要和引用队列一起使用，他的get方法永远返回null
  PhantomReference<byte[]> phantomReference = new PhantomReferene<>(
                  new byte[1024 * 1024 * 5], queue);
  System.out.println(queue.poll());
  System.gc();
  Thread.sleep(300L);
  // 根据JDK8的api文档介绍，将所有这样的引用被清除或者自身变得不可访问，
  // 也就是代码中的poll和phantomReference都为null时，GC才会回收
  Reference<? extends byte[]> poll = queue.poll();
  System.out.println(poll);
  poll = null;
  phantomReference = null;
  ```

#### JVM参数调优

- **设置堆空间的大小**：一般两值设置一样，防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间
  
  - -Xms：设置堆的初始大小
  
  - -Xmx：设置堆的最大大小
  
  - 设置一般为物理内存的1/4，太小导致频繁进行垃圾回收，会产生STW，暂停用户线程；太大如果进行FullGC会扫描整个空间，暂停应用程序线程太长

- **虚拟机栈的设置**：每个线程默认开启1M的内存空间，用于存放栈帧，调用参数，局部变量等。
  
  - -Xss：设置每个线程栈（stack）大小

- **新生代和老年代大小比例**
  
  - -Xmn：设置新生代大小，也可以调整比例
  
  - -XX:NewRatio=2：新生代和老年代的占比为1：2
  
  - 通过调整新生代和老年代的比例，可以根据应用程序的需求来优化内存管理和垃圾回收的性能。合理的调整新生代和老年代的比例，可以减少垃圾回收的频率和开销，提高应用程序的性能和稳定性。

- **年轻代中Eden区和两个Survivor区的大小比例**
  
  - -XXSurvivorRatio=8：表示Eden:Survivor1:Survivor2=8:1:1；如果值改为3，表示Eden:Survivor1:Survivor2=3:1:1；
  
  - 通过增大Eden区的大小，减少MinorGC的次数，但由于Eden区增大虽然次数减少，但每次回收时的暂停时间由于空间增大而变长，因此需要结合实际情况调整

- **年轻代晋升老年代的阈值**
  
  - -XX:MaxTenuringThreshold=15
  
  - 默认值为15，由于对象头中的分代年龄只有4位，取值范围0-15

- **设置垃圾回收器**
  
  - -XX:+UseParallelGC：JDK8默认的垃圾回收器，新生代
  
  - -XX:+UseParallelOldGC：JDK8默认的垃圾回收器，老年代
  
  - -XX:UseG1GC：设置G1垃圾回收器

#### JVM调优工具

- 命令工具
  
  - jps：进程状态信息
  
  - jstack：查看java进程内线程的堆栈信息
  
  - jmap：查看堆转信息
    
    - jmap -dump:format=b,file=xxx.hprof pid
  
  - jhat：堆转快照的分析工具
  
  - jstat：JVM统计监测工具

- 可视化工具
  
  - jconsole：用于对jvm的内存，线程，类的监控
  
  - VisualVM：监控线程、内存情况

#### Java内存泄露排查思路（重点）

- 虚拟机栈
  
  - 报错信息：StackOverFlowError

- 堆
  
  - 报错信息：OutOfMemoryError:java heap space
  
  - 出现问题：项目启动闪退、运行一段时间宕机
  
  - 解决思路：
    
    - 获取堆内存快照dump
      
      - 使用vm参数获取dump文件
        
        ```java
        -XX:+HeapDumpOnOutOfMemoryError
        -XX:HeapDumpPath=/home/app/dumps/
        ```
    
    - VisualVM去分析dump文件
    
    - 通过查看堆信息的情况，定位内存溢出问题

- 元空间（方法区）
  
  - 报错信息：OutOfMememoryError:Metaspace

#### CPU飙高排查方案与思路？（重点）

- 使用top命令查看占用cpu情况

- 找到占用较高cpu的进程id

- 使用ps命令，查看进程中的哪个线程占用cpu较高
  
  `ps H -eo pid,tid,%cpu | grep pid`
  
  

- 使用jstack命令，打印该进程的所有线程，根据上面查到的线程id，找到问题
  
  `jstack pid`
