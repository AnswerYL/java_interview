#### HashMap

##### 实现原理

- 底层数据结构
  
  - JDK1.7：数组+链表
  
  - JDK1.8：数组+（链表|红黑树）

##### 树化与退化

###### 树化的意义

- 红黑树用来避免DoS攻击，防止链表超长导致性能下降，树化应当是偶然情况，是保底策略；大部分情况下还是采用链表存储
- HashMap的查找、更新的时间复杂度理想情况下是O(1)，而红黑树的查找、更新的时间复杂度是O($log_{2}n$)；底层红黑树的存储结构TreeNode比链表的Node占用空间更大，如非必要，尽量还是采用链表
- hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，链表长度超过8的情况出现概率极低（0.00000006），将树化阈值设置成8就是为了让树化几率足够小

###### 树化的规则

链表长度超过树化阈值8后，先尝试扩容数组来减少链表长度，如果数组容量>=64时，依然有链表长度>8，才会进行树化

###### 退化的情况

1. 在数组扩容时，树进行拆分，剩余的树容量<=6，则会退化为链表
2. remove树节点时，若root、root.left、root.right、root.left.left 有一个为null，也会退化成链表（也就是树只有一边有节点）

##### 索引计算

###### 索引的计算方法（ HashMap寻址算法）

1. key.hashCode()的hash值

2. 调用HashMap的hash()方法进行二次hash（hashcode值与hashcode值右移16的值进行异或运算）

3. 二次hash后得出的hash值&数组长度（capacity – 1），进行按位与运算（替代取模）得到数组索引

###### 数组容量为何是2的n次幂

1. 计算索引时效率更高：如果是2的n次幂可以使用位与运算代替取模
2. 扩容时重新计算索引效率更高：hash&oldCapacity == 0的元素留在原来位置，否则新位置=旧位置+oldCapacity

###### 注意

- 二次hash是为了配合**容量是2的n次幂**这一设计前提，如果hash表的容量不是2的n次幂则不必二次hash
- **容量是 2 的 n 次幂** 这一设计计算索引效率更好，但hash的分散性不好，需要二次hash进行补偿，没有采用这一设计的典型例子是 Hashtable

##### put方法流程（重点）

1. 判断table是否为空，为空则执行resize方法进行初始化（容量16，加载因子0.75）

2. 根据key计算hash值，得到索引

3. 判断table[i] 是否为空
   
   1. 为空则新建node添加
   
   2. 不为空
      
      1. 判断table[i]首个元素key是否一样，一样直接覆盖value
      
      2. 判断table[i]是否为TreeNode(红黑树)，是的话则按红黑树操作
      
      3. 如果不是红黑树，则遍历table[i]，查找有相同key的元素，则直接覆盖value；没有则将数据添加到链尾，判断链表长度大于8，走扩容或转红黑树流程

4. 插入成功后，判断实际存在的元素个数，是否超过最大容量threshold(容量*加载因子)，如果超过则进行扩容

##### HashMap扩容机制（重点）

- 添加第一个元素时，调用resize初始化（默认数组长度16，加载因子0.75），扩容阈值threshold(容量*加载因子)

- 每次扩容都是扩容前容量的两倍（原有容量<<1）

- 扩容之后创建新数组，将老数组中的元素移动到新数组中
  
  - 没有hash冲突的节点，也就是说e.next为空的节点，直接重新计算索引**e.hash & (newCap - 1)**
  
  - 如果是红黑树，走红黑树的拆分，拆分后，红黑树节点个数小于等于6，则退化成链表
  
  - 如果是链表，则需要遍历链表，拆分链表，若**e.hash & oldCap==0**该元素留在原地，否则移动到**原有位置+oldCap**的地方。oldCap为原有容量

##### HashMap在JDK1.7版本，多线程死循环

JDK1.7，HashMap数据结构：数组+链表

在数组扩容时，因为链表是**头插法**，在数据迁移过程中，有可能出现死循环问题

旧HashMap：

| 0   | 1   | A    | ... |
|:---:|:---:|:----:| --- |
|     |     | B    |     |
|     |     | C    |     |
|     |     | null |     |

举例说明：

步骤一：线程 T1 和线程 T2 要对 HashMap 进行扩容操作，此时 T1 和 T2 指向的是链表的头结点元素 A，而 T1 和 T2 的下一个节点，也就是 T1.next 和 T2.next 指向的是 B 节点

步骤二：线程 T2时间片用完进入休眠状态，而线程 T1 开始执行扩容操作，一直到线程 T1 扩容完成后，线程 T2 才被唤醒，但T2线程依然指向的新Map的A节点，T2.next 指向 B 节点

线程T1扩容完成后的新HashMap：

| 0   | 1   | C    | ... |
|:---:|:---:|:----:| --- |
|     |     | B    |     |
|     |     | A    |     |
|     |     | null |     |

步骤三：T1 执行完扩容之后 B 节点的next节点是 A，而 T2 线程指向的首节点是 A，next节点是 B，这个顺序刚好和 T1 扩完容完之后的节点顺序是相反的。

T1 执行完之后的顺序是 BA，而 T2 的顺序是 ABA ，这样T2继续扩容在进行遍历链表时，死循环建立。
