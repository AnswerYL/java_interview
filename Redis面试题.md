### 使用场景

- 根据简历上的业务回答

- 缓存
  
  - 穿透、击穿、雪崩、双写一致、持久化、数据过期、淘汰策略

- 分布式锁
  
  - setnx、redission

#### 什么是缓存穿透，怎么解决？

- 定义：查询一个**不存在**的数据，数据库和redis都不存在，导致请求每次都会抵达DB

- 解决方案：
  
  - 缓存空数据
  
  - 布隆过滤器

#### Redis数据持久化策略有哪些？

RDB和AOF两者都有优缺点、一般都是结合使用

- RDB：定时对整个内存做快照
  
  - 不完整，两次备份间会丢失
  
  - 会有压缩，备份文件体积较小
  
  - 宕机恢复速度快
  
  - 数据恢复优先级低、数据完整性不如AOF
  
  - 系统资源占用高
  
  - 场景：可以容忍数分钟的数据丢失，追求更快的启动速度

- AOF：记录每一次执行的命令
  
  - 相对完整，取决刷盘方式
    
    - always：每次操作都刷盘，基本不会丢失数据，但性能差
    
    - everysec：每秒刷盘一次，最多丢失1秒数据，性能适中
    
    - no：刷盘策略由redis控制，不清楚丢失数据量，性能好
  
  - 记录命令，备份文件体积大，但可以开启重写，稍微减少命令数
  
  - 宕机恢复速度慢
  
  - 数据恢复优先级高，数据完整性高
  
  - 系统资源占用低，但AOF重写时会占用大量资源
  
  - 场景：对数据安全性要求高

#### 什么是布隆过滤器

- 一个bitmap结构，key通过多次hash得到hash值，修改bitmap中对应的位置

#### 什么是缓存击穿，怎么解决

- 定义：一个key过期，同时多个线程请求且缓存还未重建完成，大量并发可能导致DB压垮

- 解决方案：
  
  - 互斥锁
    
    - 单一线程缓存未命中，获取互斥锁，进行缓存重建，其余线程等待
    
    - 强一致、性能差
  
  - 逻辑过期
    
    - 单一线程获取缓存，结果中字段显示已过期，获取互斥锁，新建独立线程进行缓存重建，其余线程获取缓存时直接返回过期结果
    
    - 弱一致、高可用、性能优

#### 什么是缓存雪崩，怎么解决

- 定义：大量的key在同一时段、同时过期或Redis宕机，导致大量请求打到DB

- 解决方案：
  
  - 给不同的key添加过期时间时增加随机数
  
  - 利用Redis高可用集群
  
  - 给缓存服务添加降级限流措施
  
  - 给业务添加多级缓存

#### Redis双写问题

- 热点文章，实时要求不高、一致性也不高
  
  - 延时双删（更新数据库时，先删除缓存，再更新DB，然后延迟一会再次删除缓存，防止其他线程在更新DB期间，重建缓存）

- 优惠券，数量实时要求高、一致性也高
  
  - 设置读写锁
    
    - get请求，获取读锁，允许其他线程读取缓存
    
    - update\save等请求，获取写锁，保证其他读写线程都无法操作，保证数据强一致

#### Redis分布式锁如何实现

- 自己直接调用setnx实现，缺点是不好控制锁的有效时长

- 使用的是Redission实现，底层主要是setnx和lua脚本（原子性）

#### Redis分布式锁如何合理的控制锁的有效时长

在Redission分布式锁中，提供了一个**watchdog**，一个线程获取锁成功后，**watchdog**会给持有锁的线程进行续期（默认每隔10秒）

#### Redission分布式锁可以重入吗

可以，类似ReetrantLock，value中保存的有线程id和重入次数

#### Redission分布式锁能解决主从数据一致的问题吗

**主节点设置分布式锁成，主节点宕机，从节点数据还未从同步，导致其他线程依然可以在新的主节点加锁**

不能解决，但可以使用Redission提供的**红锁**来解决，但这样性能太低，建议使用**zookeeper**解决，Redis主要思想还是AP（高可用）

**红锁**：主要是用n个redis节点，将分布式锁set到（n/2+1）个节点上才算成功，但依然存在问题，只能说是减少问题

#### Redis数据过期策略有哪些

- 惰性删除：key过期后不会立即删除，如命中后检查key是否过期，过期则删除
  
  - 优点：对CPU友好，不用浪费时间进行过期检查
  
  - 缺点：对内存不友好，会有一些过期的key，一直存在内存中

- 定期删除：每隔一段时间，对一些key进行检查，删除里面过期的key（从一定量的随机key删除其中过期的key）
  
  - 定期清理两种模式
    
    - SLOW模式是定时任务，默认10hz（每秒执行10次）
    
    - FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms
  
  - 优点：可以通过限制删除操作的执行时长和频率来减少对CPU的影响，定时清理也可以有效释放过期数据占用的内存
  
  - 缺点：难以确定删除操作的时长和频率。

#### Redis数据淘汰策略有哪些

指的是redis内存不足时，对现有redis中的数据操作策略。8中淘汰策略，默认noeviction不删除任何数据，内存不足报错

**LRU**：最少最近使用。当前时间减去最后一次访问时间，值越大则淘汰优先级越高。

**LFU**： 最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。 

我的项目中用的是allkey-lru（所有key的最少最近使用，当然需要结合项目场景）

### 其他面试题

#### Redis集群有哪些方案

提高Redis的并发能力，搭建集群，实现读写分离

- 主从复制

- 哨兵模式

- 分片集群

#### 什么是Redis主从同步

- 全量同步
  
  - 从节点请求主节点同步数据（replication id，offset）
  
  - 主节点判断是否是第一次请求，主要判断从节点发过来的版本信息（replication id），如果版本信息不一致，从节点就接收主节点的（replication id和offset）进行同步
  
  - 主节点执行bgsave，生成rdb文件后，将文件发送给从节点
  
  - 在生成rdb文件期间，主节点会将新的数据以命令行的形式保存在缓冲区（repl_baklog）
  
  - 继续将生成后的命令日志文件，发给从节点进行同步

- 增量同步
  
  - 从节点请求主节点进行同步，主节点判断是否是第一次请求，如果不是就获取从节点的offset值
  
  - 主节点从命令日志中获取offset值之后的数据，发送给从节点进行同步

#### 怎么保证Redis高并发高可用

哨兵模式：实现主从集群的自动故障恢复（监控、自动故障恢复、通知）

#### 你们使用Redis是单点还是集群？哪种集群

主从（1主1从）+哨兵，单节点不超过10G内存，如果Redis内存不足，可以按照服务分配不同的Redis主从节点

#### 哨兵模式的能力

- 监控
  
  - sentinel每秒向所有的redis节点发送心跳请求（PING）
    
    - 主观下线
      
      - 如果是从节点未响应PONG的话，直接主观下线
      
      - 如果是主节点，暂时还不能确定是否真的宕机，需要多个sentinel来确认
    
    - 客观下线
      
      - 过半sentinel都未收到主节点响应PONG，主节点就被认为客观下线
    
    - 主观下线和客观下线的区别
      
      - 主观下线是当前sentinel认为节点下线
      
      - 客观下线是当前sentinel及其他sentinel都认为节点下线

- 自动故障恢复（新的主节点）
  
  - 筛选条件：从所有的从节点中选举主节点
    
    - 当前从节点在线状态，下线直接退出选举
    
    - 评估之前从节点的网络状态，总是断开连接，也退出选举
  
  - 打分：从筛选后的从节点中选举
    
    - 从节点优先级，通过 slave-priority 配置项，优先级高的直接成为主节点
    
    - 优先级一样，判断offset偏移量大小，越大证明同步数据越新，成为主节点
    
    - 在上述条件都一样的情况下，就按照runID来排序，基本上就是谁比较早运行谁成为主节点

- 通知
  
  - 将新的主节点信息同步给其他的从节点
  
  - 将新的主节点连接信息通知给redis客户端

#### Redis集群脑裂

**集群脑裂**：主节点、从节点、sentinel在不同的网络分区，sentinel监控主节点心跳中断，所以通过选举的方式找到新的主节点，这样就存在两个主节点，就是集群脑裂；此时客户端还在往老的主节点里写入数据，新节点无法同步数据，当网络恢复后，sentinel将老的主节点降为从节点，这时老的主节点从新的主节点同步数据时造成数据丢失

**解决**：我们可以修改redis配置，可以配置最少的从节点数量、缩短主从同步时间，达不到要求就暂停写入数据，避免数据丢失

#### Redis分片集群有什么作用

- 解决海量数据的存储

- 集群中有多个主节点，每个主节点可以保存不同的数据

- 每个主节点同样可以有多个从节点

- 主节点间通过ping检测彼此的健康状态

- 客户端请求可以访问集群任意节点，最终都会被转发到正确的节点

#### Redis分片集群中数据是怎么存储和读取的

- 分片集群引入了hash槽的概念，16384个hash槽

- 将所有hash槽，按需求分配给不同的实例

- 读写数据，就是根据key计算hash值，与槽取模，找到对应的实例（可以定义key中的有效部分，根据有效部分计算hash值，这样可以将同类或者同服务数据写到对应的槽中）

#### 用过Redis事务吗？事务命令有哪些

#### Redis是单线程的？为什么还那么快？

- 纯内存操作，执行速度快

- 采用单线程，避免不必要的线程切换开销及多线程安全问题

- 使用I/O多路复用模型，非I/O阻塞

#### Redis的I/O多路复用模型

- 利用单线程来同时监听多个socket，并在某个socket可读、可写时得到通知、从而避免无效的阻塞等待，充分利用cpu资源。

- 目前的I/O多路复用都是采用epoll模式实现，它会在通知socket就绪的同时，把已就绪的socket写入用户空间，不需要循环遍历socket集合判断是否就绪，提升性能。

- redis网络模型，Redis6.0之后加入了多线程            

![](/Users/liuyang/Library/Application%20Support/marktext/images/2023-11-21-18-52-50-image.png)
