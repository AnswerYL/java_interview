#### 什么是时间复杂度？

算法执行时间和数据规模之间的增长关系

#### 常见的时间复杂度有哪些?

O(1),O(N),O(logN),O(NlogN),O(N^2)

#### 异或（^）的特性

N 为一个数

- 0^N = N ，N^N=0

- A^B = B^A，(A^B)^C = A^(B^C)

#### 为什么数组索引从0开始？从1开始行不行？

- 在根据数组索引获取元素时，会用索引和寻址公式来计算内存中所对应元素位置。
  
   **寻址公式：数组的首地址+索引*数组中数据的类型大小**
  
  例如int[]数组，假如数组首地址为1012，int[3]元素的地址为1012+3*4（其中4表示int类型占用4个字节）

- 如果数组索引从1开始，寻址公式中，就会增加一次减法操作，对于CPU来说，就增加一次指令，大数据量情况下会导致性能不高。

#### 数组查找的时间复杂度？

- 随机查询（按索引查询），时间复杂度为O(1)

- 查找元素（未知下标），时间复杂度为O(n)

- 查找元素（未知下标，数组有序），通过二分查找，时间复杂度为O(logN)

#### 红黑树的特性

红黑树有以下五点性质：

- 每个结点不是红色就是黑色。

- 根结点是黑色的。

- 如果一个结点是红色的，则它的两个孩子结点是黑色的。(没有连续的红结点)

- 对于每个结点，从该结点到其所有后代叶子结点的简单路径上，均包含相同数目的黑色结点。(每条路径上的黑色结点数量相同)

- 每个叶子结点都是黑色的（此处的叶子结点指定是空结点）。

#### 对象的内存结构

在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）,实例数据（Instance Data），对齐填充。

- 对象头
  
  - markword：存储对象自身运行时数据，该部分的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit。
    
    - 无锁
    
    | 锁状态 | 25位    | 31位                       | 1位     | 4位   | 1位(偏向锁位) | 2位(锁标志) |
    | --- | ------ | ------------------------- | ------ | ---- | -------- | ------- |
    | 无锁  | unused | hashCode(调用hashCode方法时填充) | unused | 分代年龄 | 0        | 01      |
    
    - 偏向锁    
    
    | 锁状态 | 54位    | 2位         | 1位     | 4位   | 1位(偏向锁位) | 2位(锁标志) |
    | --- | ------ | ---------- | ------ | ---- | -------- | ------- |
    | 偏向锁 | 当前线程指针 | Epoch（时间戳） | unused | 分代年龄 | 1        | 01      |
    
    - 轻量级锁（自旋锁）
    
    | 锁状态  | 62位                                   | 2位(锁标志) |
    | ---- | ------------------------------------- | ------- |
    | 轻量级锁 | 指向线程栈中LockRecord的指针（通过自旋竞争锁CAS，有次数上限） | 00      |
    
    JDK1.6前：默认10次自旋，-XX:PreBlockSpin配置，或者超过CPU核数的一半，自动升级重量级锁 。  
    JDK1.6之后，自适应自旋（Adaptive Self Spinning），JVM自动调整。
    
    - 重量级锁
    
    | 锁状态  | 62位            | 2位(锁标志) |
    | ---- | -------------- | ------- |
    | 重量级锁 | 指向互斥量（重量级锁）的指针 | 10      |
  
  - Klass：klass类型指针，即对象指向类元数据的指针，虚拟机通过这个指针确定该对象是哪个类的实例。
  
  - 数组长度：只有数组对象有数组长度，如果对象为数组，对象头中必须记录数组长度。

- 实例数据：成员变量

- 对齐填充：如果（对象头+实例数据）不是8的整数倍，则通过对其填充补齐

#### CAS概念

- **名称**：CAS（Compare And Swap）比较再交换，体现一种乐观锁思想，在无锁状态下保证线程操作数据的原子性

- **使用场景**：在JDK中很多地方使用到，如synchronized，AQS，AtomicXXX类等等

- **工作原理**：操作共享变量时采用自旋锁，提高效率

- **底层实现**：CAS底层是调用Unsafe类中的方法，是由操作系统提供的，C或C++实现。

#### 解释I/O多路复用

Redis是纯内存操作，执行速度比较快，性能瓶颈时**网络延时**，多路复用是为了实现高效的网络请求

**阻塞I/O（BIO）**：两个阶段都处于阻塞状态

- 阶段一：等待数据
  
  - 用户进程**recvfrom命令**尝试读取数据（如网卡数据）
  
  - 此时数据尚未到达内核缓冲区，内核需要等待数据
  
  - 此时用户进程处于阻塞状态

- 阶段二：拷贝数据
  
  - 数据到达内核缓冲区，代表数据准备就绪
  
  - 将数据从拷贝到用户缓冲区
  
  - 拷贝过程中，用户进程依然阻塞
  
  - 拷贝完成，用户进程解除阻塞，处理数据

**非阻塞I/O（NIO）**：请求数据立即返回结果，而不是阻塞用户进程，阶段一非阻塞，但循环请求导致cpu空转，cpu使用率增加；阶段二阻塞

- 阶段一：等待数据
  
  - 用户进程**recvfrom命令**尝试读取数据（如网卡数据）
  
  - 此时数据尚未到达内核缓冲区，内核需要等待数据
  
  - 返回异常给用户进程
  
  - 拿到error后，再次尝试读取
  
  - 循环请求，直到数据就绪，但用户进程可以执行其他操作

- 阶段二：拷贝数据
  
  - 将数据从拷贝到用户缓冲区
  
  - 拷贝过程中，用户进程依然阻塞
  
  - 拷贝完成，用户进程解除阻塞，处理数据

**I/O多路复用**：利用单个线程同时监听多个socket，并在某个socket可读、可写时得到通知，从而避免无效的等待，充分利用cpu资源

- 阶段一：监听多个socket
  
  - 用户进程调用select，指定监听的socket集合
  
  - 内核监听多个socket
  
  - 任意一个或多个socket数据就绪就返回readable
  
  - 此用户进程处于阻塞状态

- 阶段二：拷贝数据
  
  - 用户进程找到就绪的socket
  
  - 依次调用recvfrom命令读取数据
  
  - 内核将数据拷贝到用户缓冲区
  
  - 用户处理数据

- 实现方式：select、poll、epoll
  
  - select和poll只会通知用户进程有socket就绪，但不确定是具体的socket，需要用户进程遍历socket集合
  
  - epoll则会在通知用户进程socket就绪的同时，把就绪的socket写入用户空间
