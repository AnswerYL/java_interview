#### 快速排序

##### 核心：

1. **每一轮排序在数组中选择一个基准点进行分区，让小于基准点的元素进入一个分区，大于基准点的元素进入另一个分区，当分区完成时，基准点元素的位置就是其最终位置；**

2. **然后再子分区内继续按步骤一进行操作，直至子分区元素个数小于等于1。**

3. **这就是分而治之思想**

##### 实现：

##### 元素交换

```java
private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```

##### 单边循环快排

###### 原理：

1. 选择最右侧元素作为基准点
2. 定义两个变量作为指针(i,j)
3. j指针遍历查找比基准点小的元素，一旦找到则与i指针所对应元素交换
4. i指针维护小于基准点元素分区的右边界，也是每次交换目标的索引位置
5. j指针遍历完一轮后，基准点元素则与i指针元素交换，同时该基准点元素位置为最终位置

```java
private static void singleSort(int[] arr, int start, int end) {
        // 若分区起始位置大于或等于结束位置，则返回
        if (start >= end) {
            return;
        }
        // 单边循环快排，确定最右侧元素为基准点
        int pv = arr[end];
        // 定义i指针，从分区起始位置开始
        int i = start;
        // 定义j指针，从左至右遍历分区元素（除最右侧元素外）
        for (int j = i; j < end; j++) {
            // 判断分区内元素是否比基准点元素小
            if (arr[j] < pv) {
                // 优化部分（若i，j指针位置一样，同时指向元素都比基准点小，可减少交换）
                if (i != j) {
                    swap(arr, i, j);
                }
                // 交换后，i指针后移
                i++;
            }
        }
        // 优化部分（若i，基准点元素索引值一样，则无需对基准点元素进行交换）
        if (i != end) {
            swap(arr, i, end);
        }
        // 递归
        // i-1：确认小于基准点分区部分，右边界
        singleSort(arr, start, i - 1);
        // i+1：确认大于等于基准点分区部分，左边界
        singleSort(arr, i + 1, end);
    }
```

##### 双边循环快排

###### 原理：

1. 选择最左侧元素作为基准点

2. 定义两个变量作为指针(i,j)

3. j指针负责从右往左遍历查找小于基准点的元素，找到后停止遍历，然后i指针开始移动，从左往右查找大于基准点的元素，一旦i指针找到，则i，j元素交换；直至i与j指针重合

4. 将基准点元素与i指针（此时i与j指针重合）元素交换，i指针位置即为分区边界

```java
private static void bothSort(int[] arr, int start, int end) {
        // 若分区起始位置大于或等于结束位置，则返回
        if (start >= end) {
            return;
        }
        // 双边循环快排，确定最左侧元素为基准点
        int pv = arr[start];
        // 定义i指针，从分区起始位置开始
        // 定义j指针，从分区结束位置开始
        int i = start, j = end;
        // 外层循环条件，i<j
        while (i < j) {
            // 由于基准点确认为最左侧元素，则先从右往左遍历查找小于基准点的元素
            while (i < j && arr[j] > pv) {
                j--;
            }
            // j指针指向小于基准点元素位置，i指针开始移动，找到大于基准点的元素
            // 注意：由于i指针起始位置和基准点位置重合，所以需要<=，否则i指针不会i++
            while (i < j && arr[i] <= pv) {
                i++;
            }
            // i指针找到大于基准点，j指针找到小于基准点，将两个元素进行交换，继续遍历
            swap(arr, i, j);
        }
        // 当i指针和j指针重合时，将基准点和i指针指向交换
        swap(arr, i, start);
        // 递归
        // i-1：确认小于基准点分区部分，右边界
        bothSort(arr, start, i - 1);
        // i+1：确认大于等于基准点分区部分，左边界
        bothSort(arr, i + 1, end);
    }
```

##### 快速排序特点

- 平均时间复杂度O($n\log_{2}n$)，最坏时间复杂度O($n^2$)
- 数据量大时，优势比较明显
- 属于不稳定排序
